
import weaver.WeaverOptions;
import lcl.LaraCommonLanguage;
import lcl.patterns.PatternsReader;
import lcl.patterns.DetectionAlgorithm;
import lcl.patterns.DetectionAlgorithmLight;
import lcl.patterns.grouping.GroupingUtils;

var PRINT_DETAILS = true;
var PRINT_RELATIONS = false;
var ALGORITHM_LIGHT = true;
var DP_CORE_COMPATIBILITY = true;
var ALGORITHM_FULL_NAMING = true;

aspectdef Detection

	/*
	for(var $class of Query.search("class")) {
	
		// if ($class.name != "TestComposite" && $class.name != "Test") continue;
		
		var result = Query.searchFrom($class, "call").get();
		print("Class: " + $class.name);	
		print("; full name: " + $class._qualifiedName);	
		println(" : calls: " + result.length);	
		// println(":: " + result);	
		// println(" Class: " + $class);		
		// println("; types: " + Array.from($class.types()));
	}
	/* */

	var algorithm = algorithmOf();

	detect(algorithm, "Abstract Factory.pattern");
	// detect(algorithm, "Abstract Factory_v2.pattern");
	detect(algorithm, "Builder.pattern");
	detect(algorithm, "Bridge.pattern");
	// detect(algorithm, "Bridge_v2.pattern");
	detect(algorithm, "Command.pattern");
	detect(algorithm, "Observer.pattern");
	detect(algorithm, "Visitor.pattern"); 

	// 				C++					Java
	// Observer		5 (4 visitors)	5 3		4 (2 visitors) / 3 3
	// Visitor		4			4 2		2			/ 1 1
	// Command		1			1 1		4 (2 builder)	/ 2 2
	// Builder		1			1 1		2			/ 1 1
	// Bridge			2			2 1		4			/ 4 2
	// Abstract Factory	4			4 4		4			/ 2 1
	
end

function algorithmOf() {

	if (ALGORITHM_LIGHT) {
		var algorithm = new DetectionAlgorithmLight([], []);
	}
	else {
		var algorithm = new DetectionAlgorithm([], []);
	}

	algorithm.setCompatibility(DP_CORE_COMPATIBILITY);
	algorithm.setFullNaming(ALGORITHM_FULL_NAMING);
	algorithm.parseRelations();
	if (PRINT_RELATIONS) printRelations(algorithm);
	return algorithm;
}

function detect(algorithm, patternFile) {

	var patternsRootDir = WeaverOptions.getData().getContextFolder() + "/patterns/";

	print(patternFile);
	
	var pattern = PatternsReader.readPattern(patternsRootDir + patternFile);
	var detections = algorithm.detect(pattern.members, pattern.connections);
	
	print(" => " + detections.length); 
	print(" , " + GroupingUtils.findSuperCandidates(pattern, detections).length); 
	print(" , " + GroupingUtils.findHyperCandidates(pattern, GroupingUtils.findSuperCandidates(pattern, detections)).length); 
	println();
	if (PRINT_DETAILS) printDetails(detections);
}

function printDetails(detections) {

	detections = detections.map(detection => detection.map(d => !d.includes('.') ? d : d.substring(d.lastIndexOf('.') + 1)));
	detections = detections.map(detection => detection.map(d => !d.includes('$') ? d : d.substring(d.lastIndexOf('$') + 1)));
		
	detections.sort((a, b) => {
		for (var i = 0 ; i < a.length && i < b.length ; i++) {
			if (a[i] > b[i]) return 1;
			if (a[i] < b[i]) return -1;
		}
	  	return 0;
	});
	for (var detection of detections) println(" - " + detection);
	// println();
}

function printRelations(algorithm) {

	println("classTypes = " + algorithm.classTypesMap.size);

	algorithm.classTypesMap.forEach((classTypeObject, classTypeName) => {

		println(classTypeName + " (" + algorithm.abstractionOf(classTypeObject.classType) + ")");
		println(" - calls      " + classTypeObject.relationCalls);
		println(" - creates    " + classTypeObject.relationCreates);
		println(" - has        " + classTypeObject.relationHas);
		println(" - inherits   " + classTypeObject.relationInherits);
		println(" - references " + classTypeObject.relationReferences);
		println(" - uses       " + classTypeObject.relationUses);
	});
}


